---
title: "Inference interractions"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
---

<script src="https://hypothes.is/embed.js" async></script>

```{r setup, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```


# List of packages 

List of packages to try :

- alien (Direct Matching Centrality, Indirect matching centrality, 4th corner, binary, Niche probabilistic, KNN as a minimal iEat)
- Hmsc (HMSC)
- boral (LVM)
- gllvm (LVM)
- ecoCopula (Gaussian Copula Graphical Model)
- PLNmodels (Gaussian Graphical Model)
- Emtree (Tree-based inferrence + PLN)
- MInt (Poisson-multivariate normal hierachical model)
- MRFcov (Markov random fields)

# Packages & data

```{r}
# Packages

## Models
#library(alien)
library(ade4)
library(Hmsc)
library(boral)
library(ecoCopula)
library(PLNmodels)
library(EMtree)
library(MInt)
library(MRFcov)
library(gllvm)

## Graph
library(ggraph)
library(tidygraph)

## Plots
library(lattice)
library(corrplot)
library(gclus)
library(viridis)

# Data

#load("Faune_cleaned_06-09-18.RData") # Not in use right now 

## seed

set.seed(42)
```

# Testing packages

## alien



## Hmsc

### Generating simulated data

```{r}
n <-  100 # Number of data points
x1 <- rnorm(n) # Covariate 1
x2 <- rnorm(n) # Covariate 2
XData <- data.frame(x1=x1,x2=x2) # Covariates

# True parameters for slope and covariates
alpha <- c(0,0,0,0,0) 
beta1 <- c(1,1,-1,-1,0)
beta2 <- c(1,-1,1,-1,0)
sigma <- c(1,1,1,1,1)

L <- matrix(NA,nrow=n,ncol=5) # Matrix of linear predictors
Y <- matrix(NA,nrow=n,ncol=5) # Matrix of generated data

for (j in 1:5){
  L[,j] <- alpha[j] + beta1[j]*x1 + beta2[j]*x2
  Y[,j] <- L[,j] + rnorm(n, sd = sigma[j])
}
```

### Estimating responses

```{r}
studyDesign <- data.frame(sample = as.factor(1:n))

rL <- HmscRandomLevel(units = studyDesign$sample)

m <- Hmsc(Y = Y, XData = XData, XFormula = ~x1+x2, studyDesign = studyDesign, ranLevels = list(sample = rL))
```

### Setting up MCMC sampling

```{r}
nChains <- 3
thin <- 1
samples <- 1000
transient <- 500*thin
verbose <- 1
```

### Sampling

```{r results ='hide'}
if(parallel::detectCores() > 2 & parallel::detectCores() > nChains){
  
  nParallel <- nChains
  
}else{
  
  nParallel <- 1
  
}

m <- sampleMcmc(m, thin = thin, samples = samples, transient = transient, nChains = nChains, verbose = 1, nParallel = nParallel)
```

### Diagnostic of the model

```{r}
mpost <- convertToCodaObject(m)

par(mfrow=c(2,2))

hist(effectiveSize(mpost$Beta), main = "ess(beta)")
hist(gelman.diag(mpost$Beta, multivariate = FALSE)$psrf, main = "psrf(beta)")
hist(effectiveSize(mpost$Omega[[1]]), main = "ess(omega)")
hist(gelman.diag(mpost$Omega[[1]], multivariate = FALSE)$psrf, main = "psrf(omega)")
```

### $\beta$ estimation

```{r}
postBeta = getPostEstimate(m, parName="Beta")
plotBeta(m, post=postBeta, param="Support", supportLevel = 0.95)
```

At $\alpha$ threshold $0.05$, We see that species 1 and 2 respond positively and species 3 and 4 respond negatively to covariable 1. Species 1 and 3 response positively to covaribale 2. Species 5 do not respond with these two variables. Estimate of intercept is of less interest because it's related to the mean abundance of each species.

### $\Omega$ estimation

```{r}
OmegaCor <- computeAssociations(m)
supportLevel <- 0.95

toPlot <- ((OmegaCor[[1]]$support > supportLevel) + (OmegaCor[[1]]$support < (1-supportLevel)) > 0) * OmegaCor[[1]]$mean

corrplot(toPlot, method = "color", col = colorRampPalette(c("blue","white","red"))(200),
title = paste("random effect level:", m$rLNames[1]), mar=c(0,0,1,0))
```

We only see intraspecifics associations because, when we generated the data, whe simulated the residuals independently for each species. In general, residual associations among species can be generated by correlated responses to missing covariates, or by ecological interactions.

### Explanatory & predictive power

```{r}
preds <- computePredictedValues(m)
evaluateModelFit(hM = m, predY = preds)
```

$R^2$ is the explanatory power, poor for specie 5. RMSE is close to $1$, because we simulated data with a $\sigma = 1$. If we want to know the predictive power, we need to use CV technics.

```{r eval = FALSE}
partition <- createPartition(m, nfolds = 2)
preds <- computePredictedValues(m, partition = partition, nParallel = nParallel)

evaluateModelFit(hM = m, predY = preds)
```

### Variance partitionning

```{r warning=FALSE}
VP <- computeVariancePartitioning(m, group = c(1,2), groupnames = c("Habitat", "Climat"))

plotVariancePartitioning(m, VP)
```

When performing a variance partitioning, we can group the fixed effects (i.e., the columns of the design matrix `head(m$X)`).

### Traits

It is possible to use traits data, we need to specify a trait coefficient 

## boral

I won't try *boral* right know, because *gllvm* seem to be much faster. 

## gllvm

### Data loading

```{r}
data("antTraits")

y <- antTraits$abund

X <- scale(antTraits$env)

TR <- antTraits$traits
```


### Model fitting

```{r}
criterias4th <- NULL

for(i in 0:5){
  
  fiti <- gllvm(y, X, TR, family = "negative.binomial", num.lv = i,
                formula = y ~ (Bare.ground + Shrub.cover + Volume.lying.CWD) + (Bare.ground + Shrub.cover + Volume.lying.CWD) :
                  (Pilosity + Polymorphism + Webers.length),
                seed = 1234)
  
  criterias4th[i+1] <- summary(fiti)$AICc
  
  names(criterias4th)[i+1]= i
}

print(criterias4th)

```

Based on *AIC*, we should choose 3 latent variables.

```{r}
fit_4th <- gllvm(y, X, TR, family = "negative.binomial", num.lv = 3, 
                 formula = y ~ (Bare.ground + Shrub.cover + Volume.lying.CWD) + (Bare.ground + Shrub.cover + Volume.lying.CWD) : (Pilosity + Polymorphism + Webers.length))
```

### Diagnostic plot

```{r}
par(mfrow = c(3, 2), mar = c(4, 4, 2, 1))
plot(fit_4th, var.colors = 1)
```

### Species association matrix

```{r}
cr0 <- getResidualCor(fit_4th)

corrplot(cr0[order.single(cr0), order.single(cr0)], diag = FALSE, type = "lower", method = "square", tl.cex = 0.5, tl.srt = 45, tl.col = "red")
```

Regions coloured in dark blue in correlation plot indicate clusters of species that are positively correlated with each other and regions coloured in dark red indicate negative correlation between pairs of species, after controlling for (co)variation in species explained by environmental terms.

### Environmental effect

```{r}
fit_env <- gllvm(y, X, family = "negative.binomial", num.lv = 3, 
                 formula = ~ Bare.ground + Shrub.cover + Volume.lying.CWD)

coefplot(fit_env, cex.ylab = 0.7, mar = c(4, 9, 2, 1), 
         xlim.list = list(NULL, NULL, c(-4, 4)), mfrow=c(1,1))
```


### Environmental-trait interraction

```{r}
coefplot(fit_4th, mar = c(4, 11, 1, 1), cex.ylab = 0.8)
fourth <- fit_4th$fourth.corner

a <- max( abs(fourth) )

colort <- colorRampPalette(c("blue", "white", "red"))
plot.4th <- levelplot((as.matrix(fourth)), xlab = "Environmental Variables", 
                      ylab = "Species traits", col.regions = colort(100), cex.lab = 1.3, 
                      at = seq(-a, a, length = 100), scales = list(x = list(rot = 45)))
plot.4th
```


## ecoCopula

### Data


```{r}
data("spider")

abund <- mvabund(spider$abund)
X <- spider$x

```

### Model fitting & plot

This kind of model ignore traits data.

```{r}
spider_mod <- manyglm(abund~X)
spid_graph <- cgr(spider_mod)

plot(spid_graph,pad=1)
```


## Emtree

### Data

I will use the same data as abose.

### Model fitting

```{r}
model <- PLN(abund~X)

p <- ncol(abund) # Number of nodes

output <- EMtree(model, maxIter = 10, plot = TRUE)
str(output)
```

### Results

```{r}
edges_prob <- output$edges_prob
edges_prob[edges_prob <2/p] <- 0

EMtree::draw_network(edges_prob, nodes_label = colnames(abund), pal="dodgerblue3", layout="nicely",curv=0.1)
```


## MInt

I don't think I will use this package, I don't understand how to use it.

```{r}
X <- system.file("extdata", "x.txt", package="MInt")

y <- system.file("extdata", "y.txt", package="MInt")

m <- mint(y=y, x=X, fmla = ~ feature1 + feature2)

m <- estimate(m) # Partial correlation matrix
```


## MRFcov